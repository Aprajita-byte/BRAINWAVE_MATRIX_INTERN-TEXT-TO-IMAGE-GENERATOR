"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.fromHeaders = exports.handleRequest = exports.DEFAULT_PROXY_ROUTE = exports.TARGET_URL_HEADER = void 0;
const tslib_1 = require("tslib");
exports.TARGET_URL_HEADER = 'x-fal-target-url';
exports.DEFAULT_PROXY_ROUTE = '/api/fal/proxy';
const FAL_KEY = process.env.FAL_KEY;
const FAL_KEY_ID = process.env.FAL_KEY_ID;
const FAL_KEY_SECRET = process.env.FAL_KEY_SECRET;
const FAL_URL_REG_EXP = /(\.|^)fal\.(run|ai)$/;
/**
 * Utility to get a header value as `string` from a Headers object.
 *
 * @private
 * @param request the header value.
 * @returns the header value as `string` or `undefined` if the header is not set.
 */
function singleHeaderValue(value) {
    if (!value) {
        return undefined;
    }
    if (Array.isArray(value)) {
        return value[0];
    }
    return value;
}
function getFalKey() {
    if (FAL_KEY) {
        return FAL_KEY;
    }
    if (FAL_KEY_ID && FAL_KEY_SECRET) {
        return `${FAL_KEY_ID}:${FAL_KEY_SECRET}`;
    }
    return undefined;
}
const EXCLUDED_HEADERS = ['content-length', 'content-encoding'];
/**
 * A request handler that proxies the request to the fal-serverless
 * endpoint. This is useful so client-side calls to the fal-serverless endpoint
 * can be made without CORS issues and the correct credentials can be added
 * effortlessly.
 *
 * @param behavior the request proxy behavior.
 * @returns Promise<any> the promise that will be resolved once the request is done.
 */
function handleRequest(behavior) {
    var _a, _b, _c;
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const targetUrl = singleHeaderValue(behavior.getHeader(exports.TARGET_URL_HEADER));
        if (!targetUrl) {
            return behavior.respondWith(400, `Missing the ${exports.TARGET_URL_HEADER} header`);
        }
        const urlHost = new URL(targetUrl).host;
        if (!FAL_URL_REG_EXP.test(urlHost)) {
            return behavior.respondWith(412, `Invalid ${exports.TARGET_URL_HEADER} header`);
        }
        const falKey = behavior.resolveApiKey
            ? yield behavior.resolveApiKey()
            : getFalKey();
        if (!falKey) {
            return behavior.respondWith(401, 'Missing fal.ai credentials');
        }
        // pass over headers prefixed with x-fal-*
        const headers = {};
        Object.keys(behavior.getHeaders()).forEach((key) => {
            if (key.toLowerCase().startsWith('x-fal-')) {
                headers[key.toLowerCase()] = behavior.getHeader(key);
            }
        });
        const proxyUserAgent = `@fal-ai/serverless-proxy/${behavior.id}`;
        const userAgent = singleHeaderValue(behavior.getHeader('user-agent'));
        const res = yield fetch(targetUrl, {
            method: behavior.method,
            headers: Object.assign(Object.assign({}, headers), { authorization: (_a = singleHeaderValue(behavior.getHeader('authorization'))) !== null && _a !== void 0 ? _a : `Key ${falKey}`, accept: 'application/json', 'content-type': 'application/json', 'user-agent': userAgent, 'x-fal-client-proxy': proxyUserAgent }),
            body: ((_b = behavior.method) === null || _b === void 0 ? void 0 : _b.toUpperCase()) === 'GET'
                ? undefined
                : yield behavior.getBody(),
        });
        // copy headers from fal to the proxied response
        res.headers.forEach((value, key) => {
            if (!EXCLUDED_HEADERS.includes(key.toLowerCase())) {
                behavior.sendHeader(key, value);
            }
        });
        if ((_c = res.headers.get('content-type')) === null || _c === void 0 ? void 0 : _c.includes('application/json')) {
            const data = yield res.json();
            return behavior.respondWith(res.status, data);
        }
        const data = yield res.text();
        return behavior.respondWith(res.status, data);
    });
}
exports.handleRequest = handleRequest;
function fromHeaders(headers) {
    // TODO once Header.entries() is available, use that instead
    // Object.fromEntries(headers.entries());
    const result = {};
    headers.forEach((value, key) => {
        result[key] = value;
    });
    return result;
}
exports.fromHeaders = fromHeaders;
//# sourceMappingURL=index.js.map